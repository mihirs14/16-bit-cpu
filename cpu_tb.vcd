$date
	Sat Mar 22 15:59:41 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module cpu_tb $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module uut $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 16 # write_data [15:0] $end
$var wire 1 $ reg_write $end
$var wire 1 % reg_read $end
$var wire 16 & reg_2_data [15:0] $end
$var wire 2 ' reg_2_adr [1:0] $end
$var wire 16 ( reg_1_data [15:0] $end
$var wire 2 ) reg_1_adr [1:0] $end
$var wire 1 * pc_jump $end
$var wire 1 + pc_branch $end
$var wire 8 , pc_address [7:0] $end
$var wire 16 - current_instruction [15:0] $end
$var wire 16 . alu_result [15:0] $end
$var wire 4 / alu_code [3:0] $end
$var wire 1 0 RAM_read $end
$var wire 16 1 RAM_output [15:0] $end
$var wire 8 2 RAM_adress [7:0] $end
$scope module CU $end
$var wire 2 3 rs2 [1:0] $end
$var wire 2 4 rs1 [1:0] $end
$var wire 4 5 opcode [3:0] $end
$var wire 16 6 instruction [15:0] $end
$var wire 8 7 adr [7:0] $end
$var reg 8 8 RAM_adr [7:0] $end
$var reg 1 0 RAM_read $end
$var reg 1 % Reg_read $end
$var reg 1 $ Reg_write $end
$var reg 4 9 alu_code [3:0] $end
$var reg 1 * pc_jump $end
$var reg 2 : reg1 [1:0] $end
$var reg 2 ; reg2 [1:0] $end
$upscope $end
$scope module PC $end
$var wire 8 < branch_adr [7:0] $end
$var wire 1 ! clk $end
$var wire 1 * jump $end
$var wire 8 = jump_adr [7:0] $end
$var wire 1 " reset $end
$var wire 1 + branch $end
$var reg 8 > address [7:0] $end
$var reg 8 ? program [7:0] $end
$upscope $end
$scope module RF $end
$var wire 1 ! clk $end
$var wire 2 @ read_adr1 [1:0] $end
$var wire 2 A read_adr2 [1:0] $end
$var wire 1 % read_en $end
$var wire 1 " reset $end
$var wire 2 B write_adr [1:0] $end
$var wire 16 C write_data [15:0] $end
$var wire 1 $ write_en $end
$var reg 16 D read_data1 [15:0] $end
$var reg 16 E read_data2 [15:0] $end
$upscope $end
$scope module alu $end
$var wire 4 F alu_code [3:0] $end
$var wire 1 ! clk $end
$var wire 16 G reg_data1 [15:0] $end
$var wire 16 H reg_data2 [15:0] $end
$var wire 1 " reset $end
$var reg 16 I accum [15:0] $end
$var reg 1 + pc_branch $end
$upscope $end
$scope module ram $end
$var wire 8 J adr [7:0] $end
$var wire 1 ! clk $end
$var wire 8 K pc_adr [7:0] $end
$var wire 1 0 read $end
$var reg 16 L out [15:0] $end
$var reg 16 M pc_out [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
x0
bx /
bx .
bx -
bx ,
x+
x*
bx )
bx (
bx '
bx &
x%
x$
bx #
1"
0!
$end
#5000
b0 ,
b0 >
b0 K
b0 ?
1!
#10000
b100000000000000 #
b100000000000000 C
b0 (
b0 D
b0 G
b100000000000000 1
b100000000000000 L
0+
b0 .
b0 I
b0 2
b0 8
b0 <
b0 =
b0 J
b0 )
b0 :
b0 @
b0 B
b1001 /
b1001 9
b1001 F
0*
1$
1%
10
b0 7
b0 3
b0 4
b100 5
b100000000000000 -
b100000000000000 6
b100000000000000 M
0!
0"
#15000
b0 2
b0 8
b0 <
b0 =
b0 J
b1 )
b1 :
b1 @
b1 B
1$
b1001 /
b1001 9
b1001 F
b1 4
b100010000000000 -
b100010000000000 6
b100010000000000 M
b0 (
b0 D
b0 G
b1 ,
b1 >
b1 K
b1 ?
1!
#20000
0!
#25000
b1111000100000100 1
b1111000100000100 L
bx000x00000x00 #
bx000x00000x00 C
0%
1*
b11 2
b11 8
b11 <
b11 =
b11 J
bx )
bx :
bx @
bx B
0$
bx /
bx 9
bx F
b11 7
b0 4
b1000 5
b1000000000000011 -
b1000000000000011 6
b1000000000000011 M
bx (
bx D
bx G
b10 ,
b10 >
b10 K
b10 ?
1!
#30000
0!
#35000
1+
b100000000000000 &
b100000000000000 E
b100000000000000 H
b100000000000000 (
b100000000000000 D
b100000000000000 G
b1111000100000100 #
b1111000100000100 C
00
b1 '
b1 ;
b1 A
b0 )
b0 :
b0 @
b0 B
b1111 /
b1111 9
b1111 F
b100 2
b100 8
b100 <
b100 =
b100 J
0*
1%
b100 7
b1 3
b1111 5
b1111000100000100 -
b1111000100000100 6
b1111000100000100 M
b11 ,
b11 >
b11 K
b11 ?
1!
#40000
0!
#45000
bx 1
bx L
b1000000000000000 #
b1000000000000000 C
b1000000000000000 .
b1000000000000000 I
0+
1$
bx 2
bx 8
bx <
bx =
bx J
b0 '
b0 ;
b0 A
b0 )
b0 :
b0 @
b0 B
10
b1000 /
b1000 9
b1000 F
b0 7
b0 3
b0 5
b0 -
b0 6
b0 M
b100 ,
b100 >
b100 K
b100 ?
1!
#50000
0!
